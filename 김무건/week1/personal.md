# MySQL 에서 최적화를 위한 설정들은 무엇일지 특히, 인덱스 에서 자료구조 관점에서 장단점 조사

1. 버퍼 풀 크기 설정 : innodb_buffer_pool_size
버퍼 풀 크기는 MySQL이 데이터를 메모리에 캐싱하는 크기입니다. 
이 값을 적절히 설정하면 디스크 I/O를 줄이고 쿼리 성능을 향상시킬 수 있습니다. 


2. 쿼리 캐시 크기 설정 : query_cache_size
쿼리 캐시 크기는 쿼리 결과를 캐싱하는 크기입니다. 
쿼리 결과를 캐싱하면 동일한 쿼리를 실행할 때 빠르게 결과를 반환할 수 있으므로 쿼리 성능이 향상됩니다. 
하지만 쿼리 캐시 크기를 너무 크게 설정하면 메모리 부족으로 인한 성능 저하가 발생할 수 있으므로 적절한 값을 설정해야 합니다.

3. 로그 레벨 설정 : log_error_verbosity
로그 레벨을 높여서 디버깅을 할 때 유용합니다. 로그 레벨을 높이면 MySQL에서 발생하는 오류 및 경고 메시지를 더 자세하게 확인할 수 있습니다.

4. 인덱스 설정 : index_merge
인덱스 설정은 데이터베이스에서 데이터를 빠르게 검색하는 데 매우 중요합니다. 
MySQL에서는 인덱스를 이용해 데이터를 검색하는데, 여러 개의 인덱스를 사용할 때 index_merge 옵션을 활성화하면 더욱 빠르게 데이터를 검색할 수 있습니다.

- index_merge 옵션??
여러 개의 인덱스를 조합해 데이터를 검색하는 옵션이다.

```sql
SELECT * FROM table_name
WHERE column1 = 'value1'
AND column2 = 'value2'
```
위에 쿼리를 살펴보면 만약에 각각의 조건에 인덱스 1,2가 존재한다면 index_merge 옵션을 사용하여
각각의 조건에 해당하는 레코드를 검색하는 것보다 빠르게 데이터를 검색할 수 있다.

5. 쓰기 작업의 지연 설정 : innodb_flush_log_at_trx_commit
   1. 트랜잭션 커밋 시 디스크에 저장 x , 버퍼 풀에 데이터 유지 -> 가장 빠르지만 시스템이 꺼지면 버퍼 풀이 날라가서 위험
   2. 커밋 시마다 디스크에 데이터 저장 : 데이터 일관성이 좋다. 하지만 성능이 떨어진다.
   3. 커밋 시 디스크에 데이터 기록 x , 버퍼 풀에 데이터를 유지하지만 1초마다 디스크에 기록 : 일관성 , 성능을 다 고려

- 기본적으로 2 방식을 사용한다. 0,2를 설정하여 성능을 높일 수 있다.

# 자료구조 관점에서 알아보자
1. MySQL은 기본적으로 B-Tree를 사용한다. 이 구조는 이진트리와 비슷하지만 다르다.
여기서 B는 바이너리가 아닌 Balance를 의미 
![img.png](img.png)![img_1.png](img_1.png)
![img_2.png](img_2.png)
- B-Tree란
바이너리 서치 트리에서 발전되어 모든 리프노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞추는 트리
이진트리와 다르게 하나의 노드에 많은 트리를 가지고 있다.

여기서 탐색의 과정을 살펴보면
1. 루트 노드에서 시작으로 하양식으로 key 검색을 수행 한다.
   - 만약에 k와 같은 키를 찾으면 탐색 종료
   - 검색하는 값들과 key들의 대소관계를 비교하며 어떠한 key 사이에 k가 존재한다면 자식 노드로 진행

2. 해당 과정은 리프 노드에 도달할 때까지 반복
3. 만약에 리프 노드에 k가 없으면 검색 실패

### 분할과 병합
- 분할은 리프 노드에 삽입을 하였을 때 새로운 키 값이 해당 리프 노드에 이미 존재하면 삽입 연산이 실패한다.
- 이때 b-tree는 리프 노드를 분할하여 새로운 키 값을 저장할 공간을 확보
- 노드가 움직이는 것이 아니라 새로운 리프 노드를 생성

- 병합은 삭제 연산을 할 때 키 값이 저장된 노드가 리프 노드인 경우 해당 노드를 삭제하고
- 리프 노드의 수를 줄인다. 이 때 인접한 노드를 합쳐서 하나의 노드로 만든다.
![img_3.png](img_3.png)
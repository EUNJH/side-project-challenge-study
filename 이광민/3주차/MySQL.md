## MySQL 8.0 구조

![image](https://user-images.githubusercontent.com/43610417/227523044-8187e695-9d0e-4650-b4d6-9181cc075829.png)

### MySQL엔진

- 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
- SQL 파서
- 전처리기
- 옵티마이저

### 스토리지 엔진

- 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 담당한다.

![image](https://user-images.githubusercontent.com/43610417/227681780-7a54f360-5290-4175-90a7-7d41d912f0d3.png)

**MySQL 서버** 는 프로세스 기반이 아닌 스레드 기반으로 동작하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

### 포그라운드 스레드
포그라운드 스레드는 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 주로 사용자가 요청하는 쿼리 문장을 처리한다. 그 후 사용자가 작업을 마치고 커넥션을 종료하면 해당 스레드는 다시 스레드 캐시로 되돌아간다. 만약 스레드 캐시에 이미 일정 개수 이상의 스레드가 대기 중이라면 해당 스레드를 종료시켜 일정 개수의 스레드만 스래드 캐시에 존재하게 한다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업을 처리한다.

### 백그라운드 스레드
InnoDB 스토리지 엔진의 백그라운드 스레드에서 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 쓰기 작업을 처리하는 쓰기 스레드이다. 쓰기 스레드는 아주 많은 작업들을 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.

일반적인 상용 DMBS에서는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있고 InnoDB 또한 이러한 방식으로 쓰기 작업을 처리한다.(MyISAM은 쓰기 버퍼링 기능을 사용할 수 없음)

이외에 인서트 버퍼를 병합하는 스레드, 데이터를 버퍼로 읽어오는 스레드, 데드락이나 잠금을 모니터링하는 스레드 등 다양한 작업들이 백그라운드 스레드에서 처리된다.

## InnoDB
핸들러에 속하는 스토리지 엔진으로 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역활을 하며 **높은 동시성 처리가 가능하고 안정적** 이며 성능이 뛰어난 스토리지 엔진

![image](https://user-images.githubusercontent.com/43610417/227682115-f5a0b6a8-3d8e-4ef0-9311-ff9490714759.png)

### 프라이머리 키에 의한 클러스터링
- 프라이머리 키는 클러스터링 인덱스(테이블 당 하나의 인덱스 허용)이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장된다.
### 외래키 지원
- InnoDB 스토리지 엔진 레벨에서만 지원한다. 
- 부모와 자식 테이블에 인덱스 생성이 필요하며 변경 시 잠금이 여러 테이블로 전파 가능성이 높다.
- foreign_key_checks(외래 키를 사용할 지 말지에 대한 제약 조건) 시스템 변수 사용
```
SET foreign_key_checks = 0;   #체크 해제
delete from subject where sub_name = 'UML';   #subject 테이블로부터 과목명(sub_name)이 UML인 과목을 삭제하고 subject 테이블 출력
SET foreign_key_checks = 1;   #체크 설정
```

### 잠금 없는 일관된 읽기
InnoDB 스토리지 엔진은 MVCC을 이용해 SERIALIZABLE이 아닌 다른 격리 수준에서는 읽기 작업이 가능하다.

![image](https://user-images.githubusercontent.com/43610417/227684838-0b2c691c-7fd0-4233-b2e5-44fd2f07e785.png)

### 자동 데드락 감지

- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 강제 종료한다.
- 언두 로그의 양이 적은 트랜잭션이 먼저 종료된다.
- 잠금 목록을 체크할 때 잠금 목록에 새로운 잠금이 걸리게 되므로 CPU 자원소모가 생길 수 있으며 해결 방법 중 하나는 innodb_deadlock_detect 시스템 변수를 OFF하고 innodb_lock_wait_timeout를 활성화하여 데드락 시 일정 시간이 지나고 요청이 실패하면 에러 메시지 반환하는 것

### 자동화된 장애 복구
Mysql서버가 시작될 때 기본적으로 자동 복구를 하는데 자동 복구가 실패할 경우 innodb_force_recovery를 사용해서 MySQL 서버를 시작해야 한다.

이때는 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다.
1~6의 값을 가지며 단계 별로 선별적 자동복구를 진행할 수 있다.

**innodb_force_recovery - 1 (SRV_FORCE_IGNORE_CORRUPT)**

InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.

**innodb_force_recovery - 2 (SRV_FORCE_NO_BACKGROUND)**

백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다. InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 이 모드로 복구하면 된다.

**innodb_force_recovery - 3 (SRV_FORCE_NO_TRX_UNDO)**

커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 MySQL 서버를 시작한다.

**innodb_force_recovery - 4 (SRV_FORCE_NO_IBUF_MERGE)**

InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다. 인서트 버퍼는 실제 데이터와 관련된 부분이 아니라 인덱스에 관련된 부분이므로 테이블을 덤프 한 후 다시 데이터베이스를 구축하면 데이터의 손실 없이 복구할 수 있다.

**innodb_force_recovery - 5 (SRV_FORCE_NO_UNDO_LOG_SCAN)**

InnoDB 엔진이 언두 로그를 모두 무시하고 MySQL을 시작할 수 있다. 하지만 이 모드로 복구되면 MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되므로 실제로는 잘못된 데이터가 데이터베이스에 남는다.

**innodb_force_recovery - 6 (SRV_FORCE_NO_LOG_REDO)**

InnoDB 엔진이 리두 로그를 모두 무시한 채로 MySQL 서버가 시작된다. 커밋됐다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시된다. 즉, 마지막 체크포인트 시점의 데이터만 남는다.

## InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간

### 버퍼

- Insert, Update, Delete처럼 데이터를 변경하는 쿼리로 변경된 데이터를 버퍼 풀이 모아서 처리한다.

### 버퍼 풀의 구조

페이지라는 조각으로 나뉘며 필요할 때 데이터 페이지를 읽어 조각에 저장한다.

**LRU(Least Recently Used) 리스트**
디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀 메모리에 유지해서 디스크 읽기를 최소화
**플러시 리스트**
디스크로 동기화되지 않은 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
**프리 리스트**
데이터가 채워지지 않은 비어있는 페이지 목록으로, 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.




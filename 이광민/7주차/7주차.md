## Session

![image](https://user-images.githubusercontent.com/43610417/233762527-e4ce2179-5708-4c75-bd65-cb0fce6d6ba6.png)


Session은 서버 측에서 인증 정보를 저장하는 방식이며 서버는 인증된 사용자의 정보를 세션에 저장하고, 해당 사용자의 요청에 대한 응답을 제공할 때마다 해당 세션 정보를 사용합니다.

세션은 일반적으로 서버 측에서 유지되며, 서버가 사용자에 대한 모든 요청에 대해 해당 세션을 확인하여 인증을 유지합니다.

## JWT 

![image](https://user-images.githubusercontent.com/43610417/233762545-3640861c-3425-460b-a5d7-54cc86a072b5.png)


JWT는 클라이언트 측에서 인증 정보를 저장하는 방식이며 JWT는 JSON 객체를 사용하여 사용자 정보를 저장하고 이 JSON 객체는 암호화되어 서명됩니다. 

그리고 서버는 해당 JWT를 검증하여 사용자를 인증하고, 클라이언트에게 요청에 대한 응답을 제공합니다. JWT는 일반적으로 서버 측에서 발급되며, 클라이언트 측에서 유지됩니다.

## JWT vs Session

### Session
Session은 서버 측에서 생성되며, JWT는 서버 측에서 발급되지만 클라이언트 측에서 생성됩니다.

세션은 서버 측에서 인증 정보를 저장하는 방식이며 인증된 사용자의 정보를 세션에 저장하고, 해당 사용자의 요청에 대한 응답을 제공할 때마다 해당 세션 정보를 사용합니다. 

사용자가 로그인을 하면 서버에서는 세션 ID를 발급하고, 이 세션 ID를 쿠키나 URL 매개변수 등을 이용해 클라이언트로 전달합니다. 

클라이언트는 이 세션 ID를 이용해 서버에 인증 요청을 하고, 서버는 해당 세션 ID를 통해 사용자를 식별하고 인증합니다. 

이후 사용자의 요청에 대한 응답을 제공할 때마다 세션 정보를 사용합니다. 세션은 일반적으로 서버 측에서 유지되며, 

서버가 사용자에 대한 모든 요청에 대해 해당 세션을 확인하여 인증을 유지합니다.

### JWT
JWT는 클라이언트 측에서 인증 정보를 저장하는 방식이며 JWT는 JSON 객체를 사용하여 사용자 정보를 저장합니다. 


https://m.blog.naver.com/shino1025/221568544633

이 JSON 객체는 암호화되어 서명됩니다. 그리고 서버는 해당 JWT를 검증하여 사용자를 인증하고, 클라이언트에게 요청에 대한 응답을 제공합니다. 

JWT는 일반적으로 서버 측에서 발급되며, 클라이언트 측에서 유지됩니다. 사용자가 로그인을 하면 서버에서는 JWT를 발급하고, 클라이언트에게 전달합니다. 

클라이언트는 이 JWT를 저장하고, 이후 사용자의 요청에 대한 응답을 제공할 때마다 해당 JWT를 서버에 전달합니다. 

서버는 해당 JWT를 검증하여 사용자를 인증하고, 요청에 대한 응답을 제공합니다.

### 사용의 차이

세션은 보안성이 중요한 경우에 사용할 수 있으며 은행이나 금융권에서 사용자 인증에 세션을 사용하는 것이 일반적입니다.

JWT는 서버 부하를 최소화하고 클라이언트 측에서 인증 정보를 저장해야 하는 경우에 유용하고 모바일 앱이나 SPA(Single Page Application)에서 사용하는 것이 일반적입니다.

JWT같은 경우 JWT의 유효성을 검증할 때에는 서명된 토큰을 검증하고, payload를 디코딩한 후 정보를 확인해야 하며 또 HTTPS프로토콜을 이용해 보안을 높혀야 합니다.

## Spring Security

### 인증
AuthenticationManager를 사용하여 인증을 처리하고 AuthenticationManager는 다양한 인증 방식을 지원하며, 인증이 성공하면 인증된 사용자 정보(Authentication)를 SecurityContextHolder에 저장합니다.

- HTTP Basic Authentication은 가장 간단한 인증 방식 중 하나입니다. 클라이언트가 서버에 요청을 보낼 때, Authorization 헤더에 사용자 이름과 비밀번호를 Base64 인코딩하여 전송합니다. 서버는 이 정보를 검증하여 인증합니다.

- HTTP Digest Authentication은 HTTP Basic Authentication과 비슷하지만, 비밀번호를 평문으로 보내는 대신, 서버가 클라이언트에게 요청하는 랜덤한 문자열(nonce)과 비밀번호를 조합하여 해시 값을 만든 후, 클라이언트가 이 값을 전송하는 방식입니다.

- OAuth 2.0은 클라이언트가 다른 서비스(예: 페이스북, 구글 등)의 사용자 정보를 이용하여 인증하는 방식입니다. 클라이언트는 먼저 해당 서비스에 인증을 요청하고, 서비스는 클라이언트에게 인증 토큰을 발급합니다. 클라이언트는 이 토큰을 이용하여 서비스에서 제공하는 API를 호출합니다.

- LDAP Authentication은 Lightweight Directory Access Protocol(LDAP) 서버에서 사용자 정보를 조회하여 인증하는 방식입니다. Spring Security에서는 LdapAuthenticationProvider를 사용하여 구현할 수 있습니다.

- SSO는 여러 개의 서비스에 대해 한 번의 인증으로 접근할 수 있도록 하는 인증 방식입니다. 대표적인 SSO 프로토콜로는 SAML, OAuth, OpenID Connect 등이 있습니다.

### 권한 부여
인증된 사용자가 특정한 자원에 접근할 수 있는 권한을 가지고 있는지를 확인하는 과정

- ACL은 특정 객체에 대한 권한 정보를 관리하는 기능입니다. 객체는 데이터베이스의 레코드, 파일, 폴더, 웹 페이지 등이 될 수 있습니다. Spring Security에서는 데이터베이스에 저장된 ACL을 사용하여 권한 부여를 수행합니다.

- Voter는 권한 부여 결정을 수행하는 객체입니다. Voter는 권한 부여 규칙에 따라 특정 사용자가 특정 자원에 접근할 수 있는지 여부를 결정합니다.

- Expression-Based Access Control
Spring Security에서는 표현식(Expression)을 사용하여 더 세밀한 권한 부여를 할 수 있습니다. 표현식을 사용하면, 특정 객체에 대한 접근 권한을 동적으로 결정할 수 있습니다. 예를 들어, "ROLE_ADMIN" 역할을 가진 사용자만 특정 자원에 접근 가능하도록 할 수 있습니다.

### 보안

인증 및 권한 부여 중에 발생할 수 있는 예외 상황을 처리하며 인증이 실패하거나, 권한이 없는 사용자가 보호된 페이지에 액세스하려고 할 때, Spring Security는 예외를 발생시키고, 해당 예외에 대한 처리를 수행합니다.

Security Configuration를 이용하여 각종 예외를 처리 할 수 있습니다. 
